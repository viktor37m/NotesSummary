# 0-1 Рюкзак
В данной разновидности задачи о рюкзаке каждый предмет можно набрать только 1 раз.

Предложим решение. Пусть $f(i, w)$ - максимальная стоимость рюкзака при рассмотрении первых $i$ предметов с сумарным весом *ровно* $w$. Если же такое невозможно то $-\infty$. Рассмотрим 2 случая:
1. Предмет $i$ не входит в рюкзак. Тогда можно убрать данный предмет и ничего не поменяется: $f(i - 1, w)$
2. Премдет $i$ входит в рюкзак. Если убрать этот предмет, то надо набрать рюкзак $f(i - 1, w - w_i)$ и прибавить $v_i$

Все значения стоит брать по максимуму. Сформируем рекурентную формулу:

$$
f(i, w) = max
\begin{cases}
0 &\text{ при } i = 0 \text{ и } w = 0 \\
-\infty &\text{ при } i = 0 \text{ и } w > 0 \\
f(i - 1, w) \\
f(i - 1, w - w_i) + v_i &\text{ при } w_i > w
\end{cases}
$$

Данный метод хорош при больших $w$ (см. Ленивое ДП), однако проще(и быстрее) писать итеративных метод.

## Итеративный подход
Будем итерироваться по `i=0..n` и `j=0..W`.
```c++
const int INF = 1e9;

vector<vector<int>> dp(n + 1, vector<int>(W + 1, -INF));
dp[0][0] = 0;
for (int i = 0; i < n; i++) {
	for (int j = 0; j <= W; j++) {
		dp[i + 1][j] = dp[i][j];
		if (j > w[i]) {
			dp[i + 1][j] = max(dp[i + 1][j], dp[i][j - w[i]] + v[i]);
		}
		// При нехватке -INF:
		// dp[i + 1][j] = (dp[i + 1][j] < 0) ? -INF : dp[i + 1][j];
	}
}

// Ответ: dp[n][W]
```

Асимптотика по памяти и времени: $O(nW)$.

Для восстановления можно всё также хранить массив `pow` и `prev` - текущий индекс элемента и с какого элемента мы взяли наилучшее значение(см.  НВП).

## Оптимизация памяти
При каждой итерации цикла мы рассматриваем только два слоя: свой и предыдущий. Из этого уже можно сделать кое-какую оптимизацию. Однако можно пойти ещё дальше: использовать только 1 слой. Заметим, что мы рассматриваем только элементы *левее* текущего. То есть можно идти по массиву справа налево, и ответ останеться прежним - мы не будем брать элементы, которые мы уже изменили
```c++
vector<int> dp(W + 1, -INF);
for (int i = 0; i < n; i++) {
	for (int j = W; j >= w[i]; j--) { // справа налево
		dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
	}
}

// Ответ: dp[W]
```