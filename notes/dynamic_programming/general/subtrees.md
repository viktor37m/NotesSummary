# ДП по поддеревьям
Динамическое программирование по **поддеревьям** - разновидность ДП, когда состоянием является поддерево в какой-то вершине. 

## Сумма всех путей
Дано дерево, на рёбрах которого есть веса. Нам хочеться узнать сумму всех путей в данном дереве.

Наивный алгоритм: перебираем все пути $n^2$ и для каждого из них считаем сумму рёбер на пути $n$. Асимптотика $O(n^3)$ что нас не сильно устраивает.

Сформируем задачу более формально. Нам нужно для каждого пути узнать сумму рёбер в  нём:

$$
\begin{matrix}
\sum_{P}{(\sum_{u \in P}{w_u})} \\
P \text{ - путь} \\
u \text{ - ребро} \\
w_u \text{ - вес ребра}
\end{matrix}
$$

Переставим скобки местами - для каждого ребра сумма путей, содержащих его, умноженное на вес ребра:

$$
\begin{matrix}
\sum_{u}{(\sum_{P | u \in P}{w_u})} = \sum_{u}{w_u \cdot p_u} \\
p_u - \text{количество путей, содержащих ребро } u
\end{matrix}
$$

Остаётся вопрос: как посчитать количество путей в дереве? Так как в дереве существует только 1 путь между 2-мя вершинами, то путь между вершинами поддеревьев $v_1$ и $v_2$ всегда будет включать данное ребро, а все остальные пути нет( $v_1$ и $v_2$ - вершины концов ребра). Количество путей между 2 поддеревьями равно $sz_{v_1} \cdot sz_{v_2}$ где $sz$ - размер поддерева. Что самое интересное: $sz_{v_2} = n - sz_{v_1}$ $n$ - сколько вершин в графе. Итоговая формула:

$$
\sum_{u}{w_u \cdot p_u} = \sum_{u}{w_u \cdot sz_{v_1} \cdot (n - sz_{v_1})}
$$

$sz$ можно пересчитывать во время работы за $O(1)$, а значит влияет только количество рёбер $n$ Асимптотика: $O(n)$

### Реализация
```c++
ll sum = 0;
vector<vector<pair<int, int>>> g;
// граф списка смежности
// v: {u1, w}, {u2, w}, ...
vector<int> sz;
// размер поддерева
  
void dfs(int v, int pred) {
	sz[v] = 1;
	for (auto [u, w]: g[v]) {
		if (u == pred) continue;
		dfs(u, v);
		sum += w * sz[u] * (n - sz[u]); // наша формула
		sz[v] += sz[u]; // пересчёт своего поддерева
	}
}

// где-то в main
dfs(0, -1);
// Ответ: sum
```

%% TODO: добавить пример %%
## Сумма путей до вершины
Дана предыдущая задача, только теперь нам нужно посчитать для каждой вершины. Для начала нужно посчитать ответ только для 1 вершины(корень). Пусть $dp_v$ - сумма путей для поддерева $v$, заканчивающихся в вершине $v$. Тогда:

$$
dp_v = \sum_{u \in g_v}{(dp_u + sz_u \cdot w_u)}
$$

$u$ - вершина, смежная с $v$ и находящаяся в его поддереве.

%% TODO: добавить картинки/схемы %%

Однако здесь мы нашли ответ только для 1 вершины $root$ - корня дерева, ведь только он учитывает всё дерево. Все остальные учитывают пути только в своём поддереве, не учитывая все остальные вершины(*наддерево*). 

Пусть $ans_v$ - ответ для вершины, как если бы она была корнем. Как её пересчитывать?

$$
ans_u = ans_v + (n - sz_u) \cdot w_u - sz_u \cdot w_u
$$

Рассматриваем ребро $v \to u$ - из предка в поддерево $u$. Мы хотим продлить все пути для наддерева вершины $u$, и убрать это ребро, если путь начинается в поддереве $u$ - данного ребра не может быть в пути.

Запускаем данный алгоритм от $root$, где $ans_{root} = dp_{root}$

### Реализация
```c++
vector<vector<pair<int, int>>> g;
vector<int> sz;
vector<int> dp;
vector<int> ans;

void dfs(int v, int pred) {
	sz[v] = 1;
	for (auto [u, w]: g[v]) {
		if (u == pred) continue;
		dfs(u, v);
		dp[v] += dp[u] + sz[u] * w;
		sz[v] += sz[u];
	}
}

void dfs2(int v, int pred) {
	for (auto [u, w]: g[v]) {
		if (u == pred) continue;
		// делаем расчёт ответа до рекурсии
		ans[u] = ans[v] + (n - sz[u]) * w - sz[u] * w;
		dfs2(u, v);
	}
}

// сначала считаем dp
dfs(0, -1);
// не забываем про базовое значение
ans[0] = dp[0];
// потом считаем сам ответ ans
dfs2(0, -1);

// Ответ для v: ans[v]
```