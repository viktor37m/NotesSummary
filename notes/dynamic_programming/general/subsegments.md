# ДП по подотрезкам
Динамическое программирование по **подотрезкам** - когда состоянием ДП является какой-то непрерывный префикс или отрезок.

## Бревно и засечки
Дано бревно длины $L$ и $N$ засечек $0 < x_1 < x_2 < \dots < x_N < L$ Разрешается пилить бревно только там, где находятся засечки. При распиле бревна мы платим за длину *целого* куска. Нужно распилить всё бревно на $N + 1$ частей за минимальную стоимость.

Обозначим $dp[l, r]$ - минимальная стоимость распилить кусок бревна, если левый край - засечка номер $l$, а индекс правого - $r$ . Заметим, что когда мы пилим какое-то бревно, оно разбивается на 2 *независимые* части. Итоговая стоимость будет $dp$ левого + $dp$ правого отрезка + длина текущего бруска. Будем итерироваться по всем засечкам бревна, делить на 2 части и брать минимальную сумму. Сформируем **рекурентную формулу**:

$$
dp[l, r] = (x_r - x_l) + \min_{m \in (l, r)}{dp[l, m] + dp[m, r]}
$$

### Итеративный подход 
Типичным способом для таких видов задач является итерация по длине отрезка. Действительно, если $r - l = 1$, отрезок единичной длины, то $dp[l, r] = 0$ , на первом шаге не надо итерироваться. 

### Реализация
```c++
const int INF = 1e9;

// input N, L
x[0] = 0; x[N + 1] = L; // 0 и L - начальные границы бревна
// input x = 0..N

vector<vector<int>> dp(N + 2, vector<int>(N + 2, INF));
for (int l = 0; l < N + 1; l++) { // начальные значения
	dp[l][l + 1] = 0;
}

for (int len = 2; len < N + 2; len++) { // по длине
	for (int l = 0, r = l + len; r < N + 2; l++, r++) { 
		// по правой r и левой l границам
		// r = l + len
		for (int m = l + 1; m < r; m++) { // по середина
			dp[l][r] = min(dp[l][r], dp[l][m] + dp[m][r]);
		}
		dp[l][r] += x[r] - x[l];
	}
}
  
// ответ dp[0][N + 1]
```

Итоговая сложность: $O(n^3)$