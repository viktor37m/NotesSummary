# НВП
**Возрастающая подпоследовательность**. Название говорит само за себя. Более формально, есть последовательность:

$$
A = (a_1, a_2, \dots, a_n)
$$

И набор индексов

$$
1 \le i_1 < i_2 < \dots < i_p \le n
$$

Таких, что выполняется

$$
a_{i_1} < a_{i_2} < \dots < a_{i_p}
$$

Как обычно, нужно найти такую **наибольшую**. Например:
```mermaid
block-beta
columns 7
A["Массив: "]

block:a:6
a1("6") a2("1") a3("5") a4("3") a5("4") a6("2")
end

I["Индексы:"]
block:i:6
ni1("1") i1("2") ni3("3") i2("4") i3("5") ni6("6") 
end

a2 --> i1
a4 --> i2
a5 --> i3
  
classDef a_style fill:#202040
classDef b_style fill:#204020
  
class a2 a_style
class a4 a_style
class a5 a_style
  
class i1 b_style
class i2 b_style
class i3 b_style
```

## Алгоритм 1
Воспользуемся динамическим программированием: пусть $dp_i$ - наименьший элемент, на который заканчивается *возврастающая подпоследовательность* размера $i$. Идём по элементам слева направо. Основная идея такая: добавить этот элемент к какой-то *ВП*. 

Заметим, что добавить какой-то элемент $a_i$ к *ВП* длиной $j$, таких что $dp_j \ge a_i$ невозможно, последний элемент больше текущего.

Найдём какой-то последний $j: dp_j < a_i$ - и добавим к этой последовательности. Тогда получиться последовательность длины $j + 1$ с последним элементом $dp_{j + 1} = a_i$ Изменение всегда произойдёт, ведь $dp_{j+1} \ge a_i$. Ко всем остальным меньшим последовательностям прибавлять не имеет смысл - мы не изменим ничего.

Можно находить $j$ втупую - проходиться по всем $n$. Асимптотика не самая лучшая $O(n^2)$. *Заметим следующее*: $dp_k < dp_{k + 1}$. \
**Доказательство.** Докажем от противного: пусть $dp_k \ge dp_{k + 1}$. Если убрать последний символ $a_{i + 1}$ из последовательности длиной $k + 1$, получится последовательность длины $k$. По определению $a_i < a_{i + 1} = dp_{k + 1}$ А значит наименьший элемент, на который заканчивается последовательность длины $k$ будет $dp_{k} \le a_i$ Итого: $dp_k \le a_i < a_{i + 1} = dp_{k + 1} \implies dp_k < dp_{k + 1}$ - пришли к противоречию.

А значит чтобы найти $j$ можно просто запустить бинарный поиск от $dp$. Итоговая асимптотика: $O(n \log{n})$.

Изначальные значения равны $+\infty$ а для $dp_0 = -\infty$ - чтобы бинпоиск всегда смог его обнаружить.

### Восстановление ответа
Просто взять массив $dp$ не получиться. Например для `a = [1, 3, 5, 2]` будет `dp = [1, 2, 5, ...]` - что неверно. Воспользуемся двумя дополнительными массивами $pos$ и $prev$:
1. $pos_i$ - индекс элемента, на который заканчивается оптимальная *ВП*
2. $prev_i$ - индекс предыдущего элемента $a_i$

Для восстановление поднимаемся вверх по массиву $prev$ с начальным значением $pos_l$ - где $l$ - длина *НВП*.
%% TODO: дописать про примеры восстановления %%

### Реализация
Итоговая реализация:
```c++
// ввод массива a

const int INF = 1e9;

vector<int> dp(n + 1, INF);
vector<int> pos(n + 1);
vector<int> prev(n + 1);
  
dp[0] = -INF;
pos[0] = -1;
int len = 0; // длина НВП
for (int i = 0; i < n; i++) {
	int j = lower_bound(all(dp), a[i]) - dp.begin(); // бин-поиск
	// dp_j >= a_i всегда
	if (dp[j] > a[i]) {
		dp[j] = a[i];
		pos[j] = i;
		prev[i] = pos[j - 1];
		len = max(len, j);
	}
}

// восстановление ответа
vector<int> ans;
int p = pos[len];
while (p != -1) {
	ans.push_back(a[p]);
	p = prev[p];
}
reverse(ans.begin(), ans.end());
```

## Алгоритм 2
%% TODO: написать ДО и объяснить %%