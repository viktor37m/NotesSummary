# Алгоритм Флойда-Уоршелла
Алгоритм **Флойда-Уоршелла** - алгоритм нахождения кратчайших путей в графе между 2 парами вершин. Как обычно, он не может работать с циклом отрицательного веса.

## Алгоритм
Основная идея: перед каждой итерацией $d[v][u]$ будет хранить длину кратчайшего пути между парами вершин $v$ и $u$, при том что путь содержит только вершины $\{1, 2, \dots, k - 1\}$ не включительно (без $v$ и $u$). Нам нужно перейти в состояние $k$.

Для начала стартовые значения: 

$$
d[v][u] = \begin{cases}
0 &\text{ если } v = u \\
w[v][u] &\text{ если есть ребро } v \to u \\
+\infty &\text{ иначе}
\end{cases}
$$

Легко доказать что это верно.

Рассмотрим какой-то кратчайший путь от $v$ в $u$ после фазы $k$. Есть 2 варианта:
1. Путь *не содержит* вершину $k$. Тогда он содержит только вершины $\{1, \dots, k - 1\}$ - ничего не поменялось, новый путь равен старому.
2. Путь *содержит* вершину $k$. Новый путь состоит из 2 частей $v \to k$ и $k \to u$. Так как все кратчайшие пути простые*, то эти два пути не содержат вершину $k$, а значит новый путь равен их сумме $d[v][k] + d[k][u]$.

*Простой путь* - тот, который не содержит повторные вершины. Если какой-то кратчайший путь содержит 2 одинаковые вершины, то он содержит цикл. Так как в графе нет цикла отрицательного веса, то его с лёгкостью можно отбросить, а значит все кратчайшие пути простые.

Объединяя эти 2 случая получаем:

$$
new \space d[v][u] = \min \begin{cases}
d[v][u] \\
d[v][k] + d[k][u]
\end{cases}
$$

Последнее улучшение: можно не хранить все матрицы состояний, а только последнее состояние $d$ - и сразу делать обновления в нем.

## Реализация
Реализация на самом деле очень проста:
```c++
const int INF = 1e9;

vector<vector<int>> d(n, vector<int>(n, INF));
for (int v = 0; v < n; v++)
	d[v][v] = 0;

// для краткости edges - список рёбер графа
// edge = {v, u, w}
for (auto edge: edges)
	d[edge.v][edge.u] = edge.w;

for (int k = 0; k < n; k++)
	for (int v = 0; v < n; v++)
		for (int u = 0; u < n; u++)
			d[v][u] = min(d[v][u], d[v][k] + d[k][u]);
```

Асимптотика: $O(n^3)$ по времени и $O(n^2)$ по памяти.

Данный алгоритм компилятором почти никак не оптимизируется, поэтому его можно использовать для проверки скорости: генерировать рандомный граф, а в самом конце вывести xor всех значений.

## Вещественные веса
Если у нас есть вещественные веса, а не целочисленные значения, то неизбежно возникает погрешность. Она имеет накопительный эффект: с каждой фазой удваивается в 2 раза, что на графах с большим количеством вершин приведёт к неправильным результатам.

Одним из путей решения данной проблемы является учитывание её в сравнении:
```c++
// погрешность
const double EPS = 1e-6;

if (d[v][k] + d[k][u] < d[v][u] - EPS)
	d[v][u] = d[v][k] + d[k][u];
```

%% TODO: взято с e-maxx.ru, проверить корректность %%
