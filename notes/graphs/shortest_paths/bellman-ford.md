# Алгоритм Форда-Беллмана
Алгоритм **Форда-Беллмана** (или Беллмана-Форда) - алгоритм нахождение кратчайшего пути в взвешанном графе (если нету цикла отрицательного веса). Главное преимущество перед алгоритмом Дейкстры - способность обрабатывать рёбра отрицательного веса.

## Алгоритм
Обозначим $d[v][i]$ - длина кратчайшего пути от $s$ до $v$ содержащего *ровно* $i$ рёбер. В самом начале все $d[v][i] = +\infty$ и $d[s][0] = 0$ - путь от стартовой вершины до стартовой содержищий 0 рёбер равен нулю. Проведём релаксацию для каждого ребра $v \to u$ с весом $w$:

$$
d[u][i + 1] = min(d[u][i + 1], d[v][i] + w)
$$

Логика в том, чтобы к минимальному пути $s \to v$ дописать ещё 1 ребро до вершины $u$. Тогда длина пути увеличиться на 1. Максимальная длина пути равна $n - 1$ - значит мы делаем ровно столько операций. Ответ для вершины будет храниться в:

$$
\min_{i \in [0, n)}{d[v][i]}
$$

-минимум от всех путей длины $[0, n)$

Однако это требует большого количества памяти: $O(n^2)$ Основная идея следующая: если есть какие-то пути длины $i$ и $j$, причём $i < j$ и $d_i < d_j$ - то для пути $j$ нам не имеет смысл делать релаксацию - в ответе такой путь всё равно не будет учитываться (как и все образованные от него).

Тогда пусть на каждой итерации $d_v$ - вес минимального пути длины $\le i$. Релаксация не особо поменялась:

$$
d_u = min(d_u, d_v + w)
$$

Тогда ответом будет просто $d_v$.

%% TODO: доказать корректность %%

## Реализация
Для данного алгоритма проще хранить граф как список рёбер:
```c++
const int INF = 1e9;

struct Edge { // структура для ребра
	int v, u, cost;
};

vector<Edge> g; // граф
vector<int> d(n, INF); // ответ

void fb(int start) {
	d[start] = 0; // начальное значение
	for (int i = 0; i < n - 1; i++) {
		for (auto edge: g) {
			// эта проверка нужна для отрицательного ребра
			// иначе каждый раз значение будут уменьшаться
			// появяться некорректные расстояния (INF - ...)
			if (d[edge.v] < INF) {
				// релаксация ребра
				d[edge.u] = min(d[edge.u], d[edge.v] + edge.cost);
			}
		}
	}
}
```

Однако также можно воспользоваться и списком смежности, перебирая каждую вершину и рёбра от неё.

Всего мы делаем $n - 1$ итераций, в каждой из которых проходим по всем рёбрам. Асимптотика: $O(n \cdot m)$

## Оптимизации
Данные оптимизации не касаются самого худшего случая, однако улучшают асимптотику *в среднем*, для рандомных графов.

**Ранее завершение.** Заметим, что не во всех графах есть кратчайший путь длины $n - 1$, а значит алгоритм можно завершить и раньше, когда никакие значения уже не обновлялись.
```c++
void fb(int start) {
	d[start] = 0;
	for (int i = 0; i < n; i++) {
		bool flag = false; // флаг для проверки
		for (auto edge: g) {
			if (d[edge.v] >= INF) continue;
			// если изменяем значение
			if (d[edge.u] > d[edge.v] + edge.cost) {
				d[edge.u] = d[edge.v] + edge.cost;
				flag = true;
			}
		}
		// выходим если нимего не случилось
		if (!flag) break;
	}
}
```

**Рандомизация рёбер.** На самом деле, за 1 итерацию цикла мы можем просмотреть пути длины более чем $i$. Однако граф специально может быть дан таким образом, чтобы мы сделали все $n$ итераций. Для борьбы с этим перемешаем все рёбра в рандомном порядке, и в среднем это поможет.
```c++
// создаём генератор рандома
random_device rd;
mt19937 generator(rd());
// перемешиваем граф
shuffle(g.begin(), g.end(), generator);
```

Для списка смежности можно перемешать рёбра для каждой отдельной вершины, а также (по возможности) изменить порядок обхода по вершинам.

**Оптимальный обход по вершинам.** Также заметим, что нам нет смысла проверять все вершины: если какую-то вершину мы ещё не посетили, или не изменили в ней значение. Заведём очередь, в которой будут храниться все изменённые вершины. Тогда алгоритм заканчивается когда очередь пуста.
```c++
// уже граф списка смежности
vector<vector<pair<int, int>>> g; 
vector<int> d;
// есть ли вершина в очереди:
// 2 раза нам нет смысла добавлять
// одну и ту же вершину
vector<bool> in_queue;

void fb(int start) {
	queue<int> q;

	// стартовые значения
	d[start] = 0;
	in_queue[start] = true;
	q.push(start);
	
	while (!q.empty()) {
		int v = q.front(); q.pop();
		in_queue[v] = false;
		// убрали элемент из очереди

		for (auto [u, w]: g[v]) {
			if (d[u] > d[v] + w) {
				d[u] = d[v] + w;
				// если нет в очереди
				if (!in_queue[u]) {
					// то добавляем
					q.push(u);
					in_queue[u] = true;
				}
			}
		}
	}
}
// также нужно быть осторожным с 
// циклом отрицательного веса
// алгоритм этого не предусматривает

// для примера можно завести массив
// длины кратчайшего пути для каждой v
// если >= n - то отриц. цикл обнаружен
```

Оптимизации можно частично совмещать. Несовместимыми остаются только 1 и 3.