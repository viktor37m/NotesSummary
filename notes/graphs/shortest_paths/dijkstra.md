# Алгоритм Дейкстры
Алгоритм **Дейкстры** - алгоритм нахождения пути в взвешанном графе, где нету неотрицательного веса.

## Описание
Пусть $d_v$ - минимальный путь от нужной вершины $s$ до данной вершины $v$.

Алгоритм действует итерационо. На первом шаге у всех вершин расстояние равно $+\infty$, а $d_s = 0$. Будем помечать маркером $used_v = 1$ те вершины, у которых мы уже нашли оптимальный путь. На каждом шаге алгоритм выбирает непомеченную вершину с минимальным весом:

$$
v = \arg \min_{u | used_u=0} d_u
$$

На первой итерации алгоритм выберет вершину $s$

Выбранная вершина помечается маркером (путь оптимален) и производиться *релаксация* рёбер: для каждого ребра $v \to u$ с весом $w$ пытаемся улучшить значение $d_u$

$$
d_u = \min{(d_u, d_v + w)}
$$

В конечном итоге, когда рассмотрены все $n$ вершин, или выбрана вершина с $d_v = +\infty$ алгоритм завершается (для оставшихся вершин пути нет).

## Корректность
Нам нужно доказать, что после работы алгоритма мы найдём кратчайший путь до вершины. Докажем по индукции: для каждой помеченной вершины $d_v$ является минимальным кратчайшим расстоянием.

**База индукции.** На первом шаге алгоритма есть только 1 помеченная вершиа $s$ а расстояние $d_s = 0$ является минимальным (рёбер отрицательного веса нет).

**Переход индукции.** Предположим, что мы выбрали вершину с номером $v$. Нужно доказать, что $d_v$ - кратчайшее расстояние от вершины $s$. Докажем от противного. Пусть существует какой-то другой путь $P$, который является $P < d_v$. Тогда этот путь может либо включать непомеченные вершины, либо нет:
1. Пусть $y$ - первая непомеченная вершина на данном пути (при чём $y \ne v$). Чтобы добраться до вершины $v$ нужно пройти ещё какие-то рёбра. А так как они неотрицательны, то должно выполняться $d_y + \text{неотрицательное значение} < d_v$ а также $d_y \ge d_v$ , ведь иначе мы бы посетили эту вершину впервее. Однако приходим к *противоречию*: $d_v - d_y > \text{неотрицательное число}$ и $d_v - d_y \le 0$ - что не может выполняться одновременно.
2. Пусть $y$ - предпоследняя вершина на пути (перед $v$), $w$ - вес ребра $y \to v$. Тогда должно выполняться: $P = d_y + w < d_v$ однако так как мы уже посещали $y$ то данное ребро уже должно быть рассмотрено: $d_y + w \ge d_v$ - *противоречие*

А значит для всех посещённых вершин наш алгоритм верен.

## Реализации
В основном есть 3 реализации данного алгоритма, они меняются лишь подходом определения минимальной вершины. Здесь мы рассмотрим только 2 самых простых (есть 3-я на Фибоначчиев куче, однако она на практике работает не особо быстрее).

### Реализация 1
Воспользуемся самым примитивным способом: будем перебирать все вершины, и находить минимальную непомеченную.

```c++
const int INF = 1e9;

vector<vector<pair<int, int>>> g(n); // граф
vector<int> d(n, INF);
vector<bool> used(n, false); // маркер

void dijkstra(int start) {
	d[start] = 0;
	for (int i = 0; i < n; i++) {
		// находим минимальную непомеченную вершину v
		int v = -1;
		for (int j = 0; j < n; j++) {
			if (!used[j] && (v == -1 || d[v] > d[j])) {
				v = j;
			}
		}
		// если нашли вершину, до которой нет пути
		// необязательно, но смысла работать дальше нет
		if (d[v] == INF) break; 
		
		used[v] = true; // маркируем v
		// релаксация рёбер
		for (auto [u, w]: g[v]) {
			// для помеченных вершин смысла нет
			if (used[u]) continue;
			d[u] = min(d[u], d[v] + w);
		}
	}
}
```

Время работы: $O(n^2 + m) \approx O(n^2)$  - на каждой из $n$ итераций перебираем все $n$ вершин + каждое ребро будет просмотрено только один раз ( при том $m \le n(n - 1)$ ).

### Реализация 2
В ней предлагается использовать кучу, например `set` или `priority_queue`. По сути нам нужно только:
1. Удалять первый элемент
2. Искать минимум
3. Обновлять значение какого-то элемента

Все эти операции делаются за $O(\log{n})$. Вместо обновления значения мы будем удалять и добавлять новый элемент.

```c++
vector<vector<pair<int, int>>> g;
vector<int> d;

void dijkstra(int start) {
	set<pair<int, int>> st; // за место кучи
	
	// базовые значения
	st.insert({0, start});
	d[start] = 0;
	
	while (!st.empty()) {
		int v = st.begin()->second; // находим вершину v
		st.erase(st.begin()); // удаляем
		
		// релаксация рёбер
		for (auto [u, w]: g[v]) {
			if (dp[u] > dp[v] + w) {
				st.erase({d[u], u}); // удаляем
				d[u] = d[v] + w; // изменяем значение
				st.insert({d[u], u}); // добавляем обновлённое
			}
		}
	}
}
```

Для `priority_queue` операции удаления нет. Можно эту операцию не использовать, а при каждом нахождении вершины `v` проверять, что `d[v] == st.pop().first`, иначе игнорировать. Из-за этого, хоть `priority_queue` работает сам по себе быстрее чем `set`, он всё же здесь проигрывает из-за дополнительных операций.

Время работы: максимум для каждого ребра мы добавим и удалим 1 значение в `set` размером $n$. Таким образом $O(m \log{n})$

---
Какой алгоритм использовать зависит от задачи: для близко к полносвязным графам быстрее работает первый, для всех остальных - второй алгоритм.
