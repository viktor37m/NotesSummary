# Отрицательный цикл
**Цикл отрицательного веса** - название понятно, это такой цикл, что сумма его весов является отрицательное значение. 

Если в графе есть такой цикл, то в нём затруднён поиск кратчайших расстояний. 

В зависимости от постановки задачи, требуется найти разный результат: детектирование, вывод всех вершин, и т. д. Также он может использоваться в других задачах (см. Минимальный средне-взвешанный цикл).

## Форд-Беллман
С помощью алгоритма Форда-Беллмана можно детектировать и выводить такие циклы. Если на $n$-ой итерации мы сделали хоть 1 релаксацию, это значит что в графе есть цикл отрицательного веса: есть какой-то кратчайший путь длиной $n$ рёбер, а значит какая-то вершина повторяется дважды.

Алгоритм также можно модифицировать для вывода *всего* цикла. Запомним вершину из которой которой была релаксация. Эта вершина либо *лежит* на цикле, либо она *достижима* из него. Чтобы гарантировано получить вершину в цикле, достаточно пройтись, например, $n$ раз (предки вершин в цикле *закольцованы*). После этого идём по предкам новой вершины, пока не придём в *себя* же.

Недостаток состоит в том, что он находит отрицательный цикл достижимый из стартовой вершины. Для исправления зададим изначально массив нулями $d_v = 0$ . Всё остальное останется неизменным.

## Флойд-Уоршелл
Стоит помнить, что если в графе есть цикл отрицательного веса, то алгоритм Флойда-Уоршелла может сломаться: отрицательный вес (как и с вещественными числами) будет накапливаться экпоненциально. Нужно его ограничить с помощью: `dp[v][u] = max(-INF, ...)`.

Алгоритм может решать другого типа задачу: существует ли кратчайшее расстояние между вершинами $v$ и $u$, и если да, то какое. Сформируем критерий: если из вершины $v$ достижим отрицательный цикл, а из него вершина $u$, то кратчайшего расстояния нет. Определять цикл отрицательного веса: если $d[t][t] < 0$, то эта вершина лежит в данном цикле.

Итого:
```c++
// ...
// изначальный алгоритм
// ...

int v = ..., u = ...;
for (int t = 0; t < n; t++) {
	if (d[t][t] < 0 && d[v][t] < INF && d[t][u] < INF) {
		// v -> u - бесконечно отрицательный путь
		d[v][u] = -INF;
	}
}
```
