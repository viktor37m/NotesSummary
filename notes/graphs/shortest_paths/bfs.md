# Поиск в ширину
**Поиск в ширину** (англ. *breadth-first search* BFS) - один из основных алгоритмов обхода графа. Также как и поиск в глубину, он посещает все вершины 1 раз, только в другом порядке.

## Основная идея
При поиске в глубину мы пытались спуститься как можно дальше - идём до самой последней вершины. В поиске в ширину мы хотим идти в порядке *отдаления* от стартовой вершины - расматривать всё по *слоям*.
![](/files/bfs.png)

## Алгоритм
Для начала будем честно хранить все слои. 

В самом начале добавляем *стартовую вершину* в 0-ой слой. Перебираем все слои от меньшего к большему, а в них все вершины. Для данной вершины смотрим другие, смежные с ней. Если они не посещены, до добавляем в следующий слой. Алгоритм заканчивается когда мы прошли все слои(от $0$ до $n - 1$).

Данная реализация не очень эффективна, однако её представление нам понадобиться далее.

**Оптимизации:**
1. Заметим, что находясь в каком-то слое $v$ мы уже просмотрели все предыдущие слои, и не будем к ним возвращаться. Они бесполезны, нам не нужно их хранить.
2. Находясь в слое $v$ мы можем добавить только в слой $v + 1$. Все следующие также не используются.
3. Если какие-то вершины находяться в одинаковом слое, то нам без разницы, в каком порядке их рассматривать - ответ от этого не поменяется.

Учтя все эти оптимизации, можно сделать алгоритм на 1 очереди: вершины добавляем в конец, а берём с начала.

## Реализация
```c++
vector<vector<int>> g; // граф
vector<int> pred; // массив предков для восстановления пути
vector<bool> used; // посетили ли мы вершину

void bfs(int start) {
	queue<int> q; // очередь
	// добавляем стартовую вершину
	q.push(start);
	pred[s] = start;
	
	while (!q.empty()) {
		int v = q.front(); q.pop(); // берём сначала
		used[v] = true;
		for (auto u: g[v]) { // проходимся по смежным вершинам
			if (!used[u]) {
				q.push(u); // добавляем в конец
				pred[u] = v; // обновляем предка
			}
		}
	}
}

// ...
// где-то в main
// start - стартовая вершина, end - конечная
bfs(start);

if (!used[end]) {
	// если не дошли до конечной вершины
}

while (end != s) {
	cout << end << " ";
	end = pred[end];
}
// !! путь выведеться в обратном порядке без вершины s
```

Время работы $O(n + m)$

## Разновидности
### Множественный BFS
Что самое интересное, мы можем запустить поиск в ширину сразу от нескольких вершин. Не надо модифицировать алгоритм. Для этого достаточно добавить все эти вершины в очередь в самом начале.

### 0-1 BFS
Теперь у нас добавляются рёбра нулевого веса. Эта задача решается не сильно сложнее.

Если мы находим ребро нулевого веса, то нужно добавить смежную вершину в данный слой, а если 1, то как в предыдущем варианте в следующий слой. По оптимизации 1 и 2 (см. Алгоритм) можно реализавать с помощью 2-х очередей, и при завершении обхода очередного слоя менять их местами.

Однако можно пойти ещё дальше, используя оптимизацию 3. Так как нам не важно в каком порядке обрабатывать вершины текущего слоя, то можно добавить вершины с 0-м рёбром в самое начало массива (где лежит текущий слой). С предыдущего алгоритма очередь поменялась на дек.

Наш дек в каком-то месте разделяется, где лежит текущий, а где следующий слой.

#### Реализация
```c++
vector<vector<pair<int, int>>> g; // граф {u, w}
vector<int> ans; // длина кратчайшего пути до s

void bfs(int start) {
	deque<int> d;

	d.push_back(start);
	ans[start] = 0;

	while (!d.empty()) {
		int v = d.front();
		d.pop_front();
		for (auto [u, w]: g[v]) {
			// если уже посетили
			if (ans[u] != -1) continue;
			
			d[u] = d[v] + w;
			if (w) { // если 1
				d.push_back(u); // добавляем в конец
			} else { // если 0
				d.push_front(u); // добавляем в начало
			}
		}
	}
}
```

### 0-k BFS
Здесь задачка уже посложнее: веса рёбер равны отрезку $[0; k]$.

Главное замечание: так как максимальное количество рёбер в пути $n - 1$ то максимальная длина пути $(n - 1) \cdot k$.

Вернёмся к первоначальной реализации: будем хранить $(n - 1) \cdot k$ очередей (либо стеков). Для слоя $v$ и ребра до $u$ весом $w$ добавляем вершину в очередь $v + w$. Как и в предыдущие разы, это требует много памяти. Заметим следующее: при обработке слоя $v$ мы можем перейти в слои:

$$
v, v + 1, v + 2, \dots, v + k
$$

Это эквивалент 2-му свойству. Объединяем с 1-м и получаем, что используются только слои с $v$ по $v + k$ - всего $k + 1$ очередей. Новые элементы добавляем в $v + w \pmod k$ очередь.

Такой алгоритм будет работать за $O(kn + m)$. Если задано ограничение на максимальную длину пути в графе $K$ то скорость работы $O(K + n + m)$.