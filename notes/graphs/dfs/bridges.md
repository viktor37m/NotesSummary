# Мосты
**Мост** - такое ребро, при удалении которого граф распадается на 2 компоненты связности. То есть единственный путь, чтобы попасть из 1-го поддерева в другое является это ребро. \
**Задача.** Быстро найти все такие ребра.

Самый наивный алгоритм: удаляем ребро и смотрим, есть ли путь $u \to v$. Однако такой алгоритм работает за $O(m^2)$. 

Посмотрим на обход в глубину $dfs$. Разделим все рёбра на 2 типа:
1. **Прямые** - те, по которым мы ходили во время обхода
2. **Обратные** - те, по которым $dfs$ не перешёл, так как ранее мы уже просматривали вершину, к которой ведёт это ребро

![](/files/dfs-bridge.png)

Заметим, что никакие *обратные* рёбра не являются мостами, ведь если их убрать, граф не распадётся. Также заметим, что обратные ребра могут вести только *вверх*, но не в другие *ветви* графа, иначе бы ребро было не обратным: во время обхода нам бы обязательно оно встретилось, и нам пришлось бы по нему пройти.

Докажем следующее: ребро $v \to u$ не является мостом, если в поддереве $u$ есть обратное ребро, ведущее выше, чем $v$. Если его удалить, то граф не распадётся: по обратному ребру вершина $u$ сможет соединиться с остальными.

Для решения *введём* величину $ret_v$ - минимальная высота вершины, до которой мы можем добраться с помощью обратного ребра:

$$
ret_v = \min_{u \in g_v}
\begin{cases}
h_v \\
ret_u \text{ - прямое ребро} \\
h_u \text{ - обратное ребро}
\end{cases}
$$

Где $h_v$ - высота текущей вершины (для корня - 0, для других - высота предка + 1), а $u$ - все дочерние вершины.

По определению:

$$
ret[v] \le h[v]
$$

Тогда есть 2 случая для ребра $v \to u$:
1. $ret_u < h_u$ - не мост - есть какое-то обратное ребро
2. $ret_u = h_u$ - мост - нет обратного ребра

Итоговая скорость: $O(n + m)$.

Стоит отметить, что если в графе есть *кратные* рёбра, то проверку на ребро к предку надо делать иначе: не обрабатывать только первое ребро, ведущее к предку, а все остальные стоит учесть.