# Неявное ДО
Пусть у нас есть очень большой массив($n \le 10^9$), однако он никак не задан изначально, а также нужно отвечать на $q \le 10^5$ запросов, 2 типов
1. Сумма на отрезке $[l, r]$
2. Присвоить $a_i = x$

Основная логика здесь такова: так как запросов у нас не так много, по сравнению с массивом, то не каждый элемент массива будет задан, то есть большенство так и останется равным нулю. Тогда мы может не хранить такие вершины, сохраняем только те, в которых хоть что-то изменилось. Такое дерево называется **неявным**.

Теперь дерево не получиться упаковать - это будет уже явное дерево, которое не подходит нам из-за памяти. Сделаем следующий трюк: создадим массив вершин(сначала пустой), а в каждой вершине будем хранить номер на левого и правого сына в этом массиве. 
```c++
struct Node {
	int l = -1; // номер на левого сына
	int r = -1; // номер на правого сына
	long long value = 0; // нейтральный элемент
};

vector<Node> t;
```

Теперь нам нужно подстроить все функции под неявное ДО. Начнём с изменение элемента($a_i = c$):
```c++
// Здесь [l, r) - полуинтервал, так как
// в самой вершине мы до сих пор это не сохраняем
void update(int v, int l, int r, int i, int x) {
	if (r - l == 1) { // единичный отрезок
		t[p] = x;
		return;
	}
	int m = (l + r) / 2; // всё так же середина
	if (i < m) {
		update(t[v].left(), l, m, i, x);
	} else {
		update(t[v].right(), m, r, i, x);
	}
	// обновляем текущую вершину
	t[v].value = merge(t[v].get_left(), t[v].get_right());
}
```

Однако теперь у нас появилось 2 новых функции для вершнины `left()` и `right()` - это сделано специально, чтобы избежать обращение к несуществующей вершине. Поэтому нам сначала нужно её создать.

Различие между `left()` и `get_left()` заключается в том, что если нету ноды, то в первом случае мы её создаём, а во втором возвращаем нейтральный элемент. Примерная реализация:
```c++
// Где-то в struct Node {...}

// Возвращает номер в массиве
int left() {
	if (l == -1) {
		t.push_back({}); // добавляем пустую ноду
		l = t.size() - 1; // записываем её
	}
	return l;
}

// Возвращает саму ноду
Node get_left() {
	if (l != -1) {
		return t[l];
	} 
	return {};
}

// Тоже самое для right() и get_right()
```

Аналогичным образом делаем функцию получения элемента:
```c++
Node get(int v, int l, int r, int lq, int rq) {
	// добавляем проверку на существование ноды
	if (v == -1 || l >= rq || r <= lq) {
		return {};
	} else if (l >= lq && r <= rq) {
		return t[v];
	} 
	// остальное всё тоже самое
	int m = (l + r) / 2;
	Node left = get(t[v].l, l, m, lq, rq);
	Node right = get(t[v].r, m, r, lq, rq);
	return merge(left, right);
}
```

Не забываем, что в начале работы программы нужно добавить корневую вершину `root`.

Асимптотика функций не поменялась, а всего памяти неявное ДО занимает $O(q \cdot \log{n})$ - для каждого запроса создаём максимум $\log{n}$ вершин(высота дерева).

## Сжатие координат
Надо заметить, что если нам известны все запросы заранее(*офлайн* задача), то решается это более проще: можно сжать координаты. 
%% TODO возможно дописать более подробно(хотя это не основная тема) 4:15 лекция %%
